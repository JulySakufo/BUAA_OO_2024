同学们好，本周小组讨论提供以下几个选题
- 如何完成博客作业，如何选择和使用统计和可视化工具？
 - 第一单元里如何进行表达式的化简？好的架构能够带来什么优势？
 - 在重构和迭代第一单元作业中积累了哪些方法和技巧？在作业中对SOLID原则有什么体会？
 （SOLID原则包括SRP,OCP,LSP,ISP,DIP）

补充：电梯是怎么运作的



# 问题1

- MetricsReloaded 复杂度分析
- 手动绘图drawio
- 自动生成类图
- 插件：PlantUML integration PlantUML Parser 

如何完成博客作业：分别列出三次作业的分析历程，解决思路，是如何发现自己在编写时的bug并改正的，如何生成了属于自己的hack数据。

# 问题2

过程中的化简

- 如果统一最后合并可能导致超时或者内存溢出

- 解析的时候合并相同系数
- 在Poly的加法实现过程中实现合并

最终的优化

- 遍历gcd找到最大公因式，如果提出后长度变短则直接提出
- 陈佬的方法 讨论区



架构的优势：

- 方便最后的优化：层算分离会导致最后的化简很复杂
- 扩展性高
- Unit-Poly 的架构在第三次作业中不会增加很多工作量

# 问题3

方法技巧：

选取一个好的架构。对全局性的把握，猜想未来会有的迭代，保留迭代空间，选取利于迭代的架构，比如第一次的hashmap就是很难迭代的。

深克隆与浅克隆根据目的需求使用，是否修改？怎样修改？

尽量具有面向对象编程的特性而不是面向过程，相对于落实到细节更注重整体性。这样在写代码的时候考虑逻辑的衔接会很顺利。

- SOLID原则

在作业中，大多数人是实现了Factor接口，这是针对迭代需求合理设计的。只要有因子扩增需求，只需要新增符合迭代需求的类即可，对应了SOLID原则中的开闭原则。

第二，比如poly与mono之间的关系。mono作为基本项，应该作为运算的载体而不是运算的主体，poly装有mono，它才是运算的主体，运算的方法应该主要写于poly中。这对应了单一职责原则。

第三，实现的factor接口里面的抽象方法很少，只提取了所有因子都有的方法，这对应了接口隔离原则。

# 补充：电梯的运作

主要考虑了几种情况，分别是

### 先到先得

根据乘客请求的先后顺序进行调度，**即，谁先按电梯先服务谁。**



### **最短优先**

按照最短距离服务，**即，电梯离谁最近先服务谁。**



### **顶层底层之间往返循环**

在底层和顶层之间往返运行，响应方向相同的请求。即，上下循环往返，有顺路的就带上，走到顶层或底层再掉头。它的改进是到了用户请求的最高层，就可以掉头。目前电梯大多采用这种逻辑，但是它的效率并不是最高的。因为这个方案，电梯会经常回头接人，而电梯回头会导致乘坐人的体验很怪异。比如我从1楼乘坐电梯去30楼，电梯到10楼时收到9楼有人请求上行，电梯回到9楼接了个人继续上升。我的体验是1->10->9->30，这感觉起来很奇怪。

