# OO作业随笔记录-第二单元-电梯

## 第一次作业

显然电梯要`extends Thread`，每一个电梯都是单独一个子线程，Elevator类

具有的属性 boolean doorState，考虑开关门，**电梯只有开门才可以关门，只有关门才可以开门**

**准确来说，评测逻辑是：带时间戳的输入->datainput（数据投喂包）->不带时间戳但是会按照真实时间投喂的输入->ElevatorInput（你的程序调用的官方包）->PersonRequest的一个实例按照这个逻辑所以进入你的java程序的输入确实没有时间戳，**通过以上逻辑，实现模仿真实生活中的场景，在xx.xxxx秒一个人按下了电梯，然后程序开始响应这个request



电梯**上下行，开关门的动作**以及**控制乘客进出电梯**，属于电梯这个对象的逻辑行为，方法写在elevator中

**生产者-消费者模型**

输入线程作为生产者，电梯作为消费者，有生产则有消费

| 类               | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| Dispatcher(线程) | 调度作用。接受乘客信息，将需求调度到乘客想坐的电梯的侯乘表中 |
| RequestTable     | 侯乘表。每部电梯应该都有一个，因为乘客想坐不同的电梯         |
| Elevator(线程)   | 接受侯乘表的信息，得到对应的行动策略，每部电梯有自己的行动策略，互不影响，是多线程。 |

**指定了电梯，不会出现两部电梯竞争一个乘客的现象**

这次作业真的会有地方需要`synchronized`吗？？？感觉线程之间没有数据共享啊

电梯没有思考功能，只是工具人，进行思考完成一部电梯怎么运作的是它的大脑，即它的strategy，strategy告诉它怎么做，它就怎么做。电梯编写行为函数，strategy编写判断行为函数。**面向对象特性，各有各的方法**

将当前电梯的状态输入给strategy，strategy选择出行动方案。<img src="C:\Users\28670\AppData\Roaming\Typora\typora-user-images\image-20240326184225877.png" alt="image-20240326184225877" style="zoom:50%;" />

电梯的行为

有人下或上都是OPEN后顺带的动作，核心是要OPEN，为什么OPEN，因为有人要上下



`public synchronized void method`锁住的是这个对象实例，即用这个方法时，其他用的这个对象实例的不能运行，只能等这个线程运行完这个方法，把锁释放出来



## 第二次作业

没有指定哪部电梯，需要自己设定调度策略。

- 空闲的响应新增需求，checkRequestTable看是否有电梯的侯乘表是空的，有的话就加进去。

几部电梯到这个请求的远近。(不要让电梯停下来)

- (均分请求？) 感觉一般，应该有可以改进的地方
- 对于同时到来的多个请求，尽量使得一个电梯的运动方向单调，即上升电梯负责上升，下降电梯负责下降。

- 保持电梯当前乘坐的人的到达方向与电梯方向相同，减少复杂度，提高期望


RECEIVE应该在addRequest的时候执行输出，表示已完成该request的分配

从乘客挑选电梯变成了电梯挑选乘客

**先做一个随机挑选乘客的作为性能衡量的基准，先完成功能更新，再完成调度策略的改变。功能与调度分离，互不影响，调度请求给电梯，电梯完成功能执行即可**

**random大法 less is more**

**均分**

**自我设计**

**不要让电梯超负荷运转，均分的思想是减少每个电梯的人数，从而减少时间，防止tle！**



### Hack数据思路

设计一个到这层时发送一个该层乘坐电梯的请求，考察的是receive和in的顺序。



## 第三次作业

双轿厢电梯，应该实现将人实现送到后，马上离开换乘楼层，[startFloor,endFloor]是运营范围，一经送达换乘楼层，立马实现离开，以给另外一部电梯接走乘客的空间
